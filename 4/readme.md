
<!-- AAAA -->
Напишите генератор, возвращающий бесконечную последовательность чисел из треугольника Паскаля.
Сдавать нужно только код самого генератора, тестирующий код импортирует его и прогонит набор тестов.
Последовательность, возвращаемая генератором, должна выглядеть так:
1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 1 8 28 56 70 56 28 8 1 1 9 36 84 126 126 84 36 9 1 ...
Формат ввода

Требуется реализовать генератор в виде функции без аргументов с именем pascal_triangle.
Текст програмы должен содержать генератор pascal_triangle и все необходимые импорты.

Файл с решением должен называться solution.py

<!-- BBBB -->



Напишите генератор, выполняющий слияние отсортированных последовательностей целых чисел.
Сдавать нужно только код самого генератора, тестирующий код импортирует его и прогонит набор тестов.
Генератор принимает произвольное число аргументов. Аргументом может быть любой итерируемый объект, в том числе другой генератор. Гарантируется, что каждый аргумент — это последовательность целых чисел, отсортированных в порядке неубывания.
Формат ввода

Текст программы должен содержать генератор с именем merge_sorter и все необходимые импорты.
Примечания

1. Для ручной итерации может понадобиться функция next(): https://docs.python.org/3/library/functions.html.
При завершении итерации функция next() бросает исключение StopIteration. Пример обработки исключения: https://pastebin.com/zqjDphcK.

2. Для реализации слияния может пригодиться модуль heapq: https://docs.python.org/3.0/library/heapq.html. 

<!-- CCCC -->



Напишите декоратор @takes, который будет проверять правильность типов входных аргументов функции.

Декоратор принимает на вход типы аргументов и декорирует функцию таким образом, что она генеририрует исключение TypeError, если хотя бы один из аргументов имеет неверный тип.

Если аргументов больше, чем типов, то ошибку генерировать не нужно (возможно, точный тип известен только для первых аргументов, его, как раз, надо проверить).

Если типов больше, чем аргументов, то это тоже ошибка только в случае, если переданные аргументы не подходят под соответствующие им по порядку типы. (декоратор может быть применен к функциям с переменным числом аргументов).

Декоратор должен вести себя порядочно, то есть не должен затирать основные аргументы функции (__name__, __doc__, __module__).

Для простоты можно считать, что у функции нет именованных аргументов.

Генерацию исключений воспринимайте пока как волшебный способ просигнализировать об ошибке. Делается это так: raise TypeError
Формат ввода

Ваш код должен иметь такой вид:

import sys

...

ваши импорты и реализация

декоратор должен называться "takes"

...

exec(sys.stdin.read())

(Программа выполнит код, записанный во входном файле)

<!-- DDDD -->

 Бывает полезно оптимизировать вызовы "тяжёлых"функций с помощью кеширования. Кеширование – это сохранение результатов выполнения функций для предотвращения повторных вычислений. Перед вызовом функции проверяется есть ли уже вычисленный результат. Если есть – функция не вызывается, а возвращается сохранённое значение.

Реализуйте декоратор для Least Recently Used (LRU) Cache. Пользователь указывает размер кеша N, и в кеше сохраняются N последних вычислений. Другими словами, вытесняется из кеша сначало то, что использовалось давней всего.

Декоратор назовите @cache, он должен принимать один параметр – размер кеша. Поддержите как можно более широкий класс функций (функции многих аргументов, функции с именоваными параметрами, принимающие сложные типы итд). Декоратор должен вести себя порядочно, то есть не должен затирать документацию функции.

Пример работы
Вот такой код
@cache(2) 
def foo(value): 
        print(’calculate foo for {}’.format(value)) 
        return value 
 
foo(1) 
foo(2) 
foo(1) 
foo(2) 
foo(3) 
foo(1)

должен произвести такой вывод
calculate foo for 1 
calculate foo for 2 
calculate foo for 3 
calculate foo for 1

Сдавать нужно только код самого декоратора, тестирующий код импортирует его и прогонит набор тестов.

Версия питона python3.4. Использовать lru-кэш из functools нельзя. Использовать sys нельзя.

Аргументы декорируемых функций гарантированно являются hashable-объектами. 

<!-- EEEE -->

 Напишите декоратор @proﬁler, который при вызове функции будет сохранять в её атрибуты время ее исполнения (в секундах, можно дробное) и количество рекурсивных вызовов, произошедших при исполнении. Атрибуты назовите last_time_taken и calls.

Пользоваться глобальными переменными запрещено.
Декоратор должен вести себя порядочно, то есть не должен затирать документацию функции.

Сдавать нужно только код самого декоратора, тестирующий код импортирует его и прогонит набор тестов. Тестирующий код импортирует из вашего модуля декоратор и прогонит на наборе тестов.

Версия питона 3.4

Проверить работу ваших декораторов стоит на функции Аккермана и на функции, принимающей в себя произвольное число списков и склеивающей их в один. Обе этих функции реализуйте сами. Описание функции Аккермана см по ссылке. функция Аккермана
Аккермана удобно проверять с аргументами (3,4)).

Пример использования декоратора


import time


@profiler
def sleepy_recursion(num_calls):
    "I am a strange sleepy recursive function"
    time.sleep(1)
    if num_calls > 1:
        sleepy_recursion(num_calls - 1)


sleepy_recursion(3)

print(sleepy_recursion.__doc__)
print(sleepy_recursion.last_time_taken)
print(sleepy_recursion.calls)

I am a strange sleepy recursive function
3.003287
3
